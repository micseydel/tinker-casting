package me.micseydel.model

import cats.data.ValidatedNel
import cats.implicits.{catsSyntaxTuple2Semigroupal, catsSyntaxTuple3Semigroupal, catsSyntaxValidatedId}
import me.micseydel.util.RasaUtil
import spray.json._

case class Entity(confidence_entity: Double,
                  confidence_group: Option[Double],
                  end: Int,
                  entity: String,
                  extractor: String,
                  group: Option[String],
//                  processors: List[String],
                  start: Int,
                  value: String)

case class Intent(confidence: Double, name: String)

case class IntentRanking(confidence: Double, name: String)

//case class Response(confidence: Double,
//                    intent_response_key: Option[String],
//                    responses: Option[List[String]],
//                    utter_action: String)
//
//case class ResponseSelector(all_retrieval_intents: List[String], default: Response)

case class RasaResult(entities: List[Entity],
                      intent: Intent,
                      intent_ranking: List[IntentRanking],
//                      response_selector: ResponseSelector,
                      text: String,
                      text_tokens: List[(Int, Int)])

// the above captures the JSON generated by Rasa
// this last case class is just a wrapper to associate a request with an ID

///**
// * @param request_identifier could be a JSON Whisper filename (specific to the model!)
// */
//case class RasaResultWrapper(rasa_result: RasaResult, request_identifier: String)

object RasaResultProtocol extends DefaultJsonProtocol {
  implicit val entityFormat: RootJsonFormat[Entity] = jsonFormat8(Entity)
  implicit val intentFormat: RootJsonFormat[Intent] = jsonFormat2(Intent)
  implicit val intentRankingFormat: RootJsonFormat[IntentRanking] = jsonFormat2(IntentRanking)
//  implicit val responseFormat: RootJsonFormat[Response] = jsonFormat4(Response)
//  implicit val responseSelectorFormat: RootJsonFormat[ResponseSelector] = jsonFormat2(ResponseSelector)
  implicit val rasaResultFormat: RootJsonFormat[RasaResult] = jsonFormat5(RasaResult)
//  implicit val rasaResultWrapperWrapper: RootJsonFormat[RasaResultWrapper] = jsonFormat2(RasaResultWrapper)
}

//sealed trait KnownIntent
//
//sealed trait CatIntent extends KnownIntent
//
//case object ObservedLitterBeingUsed extends CatIntent {
//  def unapply(intent: Intent): Option[ObservedLitterBeingUsed.type] = intent match {
//    case Intent("observed_litter_being_used", _) =>
//      Some(ObservedLitterBeingUsed)
//    case _ =>
//      None
//  }
//}
//
//case object PosthocLitterObservation extends CatIntent {
//  def unapply(intent: Intent): Option[PosthocLitterObservation.type] = intent match {
//    case Intent("posthoc_litter_observation", _) =>
//      Some(PosthocLitterObservation)
//    case _ =>
//      None
//  }
//}
//
//case object ObserveSiftedContents extends CatIntent {
//  def unapply(intent: Intent): Option[ObserveSiftedContents.type] = intent match {
//    case Intent("observe_sifted_contents", _) =>
//      Some(ObserveSiftedContents)
//    case _ =>
//      None
//  }
//}
//
//case object SetTheLights extends KnownIntent {
//  def unapply(intent: Intent): Option[SetTheLights.type] = intent match {
//    case Intent("set_the_lights", _) =>
//      Some(SetTheLights)
//    case _ =>
//      None
//  }
//}
//
//case object NoIntent extends KnownIntent {
//  def unapply(intent: Intent): Option[NoIntent.type] = intent match {
//    case Intent("no_intent", _) =>
//      Some(NoIntent)
//    case _ =>
//      None
//  }
//}

//sealed abstract class RasaIntention(val intention: String) {
//  val confidence: Double
//
//  def unapply(rasaResult: RasaResult): Option[this.type]
//}
//
//case class _CatIntent(confidence: Double) extends RasaIntention("observed_litter_being_used") {
//  override def unapply(rasaResult: RasaResult): Option[_CatIntent.this.type] = rasaResult match {
//    case RasaResult(entities, Intent(confidence, "observed_litter_being_used"), _, text, _) =>
//      Some(_CatIntent(confidence))
//    case _ => None
//  }
//}

sealed abstract class KnownIntentADT[KI <: KnownIntent](val IntentName: String) {

  protected def entitiesMapToValidated[T](
     entitiesMap: Map[String, String],
     entityName: String,
     adapter: String => Option[T]
   ): ValidatedNel[String, T] =
    RasaUtil.entitiesMapToValidated(entitiesMap, entityName, adapter)

  protected def entitiesMapToValidatedOptional[T](entitiesMap: Map[String, String], entityName: String, adapter: String => Option[T]): ValidatedNel[String, Option[T]] =
    RasaUtil.entitiesMapToValidatedOptional(entitiesMap, entityName, adapter)

  protected def unapplyHelper(rasaResult: RasaResult)(entitiesMapAndConfidenceToKnownIntent: (Map[String, String], Double) => ValidatedNel[String, KI]): Option[ValidatedNel[String, KI]] = {
    rasaResult match {
      case RasaResult(entities, Intent(confidence, IntentName), _, text, _) =>
        val entitiesMap: Map[String, String] = RasaUtil.entitiesToMap(entities)
        Some(entitiesMapAndConfidenceToKnownIntent(entitiesMap, confidence))

      case _ =>
        None
    }
  }
}






object KnownIntent {
  case object observed_litter_being_used extends KnownIntentADT[ObservedLitterBeingUsed]("observed_litter_being_used") {
    def unapply(rasaResult: RasaResult): Option[ValidatedNel[String, ObservedLitterBeingUsed]] = {
      unapplyHelper(rasaResult) { (entitiesMap, confidence) =>
        val validatedLitter = entitiesMapToValidated(entitiesMap, "litterbox", LitterBoxChoice.unapply)
        val validatedCat = entitiesMapToValidatedOptional(entitiesMap, "cat", CatOfMine.unapply)
        val validatedUncertainty = entitiesMap.get("uncertainty").validNel

        (validatedLitter, validatedCat, validatedUncertainty).mapN { (litterbox, maybeCat, maybeUncertainty) =>
          ObservedLitterBeingUsed(confidence, litterbox, maybeCat, maybeUncertainty)
        }
      }
    }
  }

  case object posthoc_litter_observation extends KnownIntentADT[PosthocLitterObservation]("posthoc_litter_observation") {
    def unapply(rasaResult: RasaResult): Option[ValidatedNel[String, PosthocLitterObservation]] = {
      unapplyHelper(rasaResult) { (entitiesMap, confidence) =>
        val validatedLitter = entitiesMapToValidated(entitiesMap, "litterbox", LitterBoxChoice.unapply)
        val validatedIsClean = entitiesMapToValidated(entitiesMap, "litterstatus", isCleanAdapter)

        (validatedLitter, validatedIsClean).mapN { (litterbox, isClean) =>
          PosthocLitterObservation(confidence, litterbox, isClean)
        }
      }
    }

    private def isCleanAdapter(string: String): Option[Boolean] = {
      string.toLowerCase.strip() match {
        case "clean" | "unused" | "unsoiled" => Some(true)
        case "dirty" | "soiled" | "used" => Some(false)
        case _ => None
      }
    }
  }

  case object observe_sifted_contents extends KnownIntentADT[ObserveSiftedContents]("observe_sifted_contents") {
    def unapply(rasaResult: RasaResult): Option[ValidatedNel[String, ObserveSiftedContents]] = {
      unapplyHelper(rasaResult) { (entitiesMap, confidence) =>
        val validatedLitter = RasaUtil.entitiesMapToValidated(entitiesMap, "litterbox", LitterBoxChoice.unapply)
        val validatedSiftedContents = entityMapToValidatedSiftedContents(entitiesMap)

        (validatedLitter, validatedSiftedContents).mapN { (litterbox, siftedContents) =>
          ObserveSiftedContents(confidence, litterbox, siftedContents)
        }
      }
    }

    private def entityMapToValidatedSiftedContents(entitiesMap: Map[String, String]): ValidatedNel[String, SiftedContents] = {
      // RasaUtil.entitiesMapToValidated expects a missing key to be bad, so we can't use it here
      // we treat non-mentions here as a legit 0, and >3 ("three") as not recognized

      object MaybeWordAsCount {
        def unapply(word: Option[String]): Option[Int] = word match {
          case None => Some(0)
          case Some("one" | "a") => Some(1)
          case Some("two" | "couple") => Some(2)
          case Some("three") => Some(3)
          case _ => None
        }
      }

      (entitiesMap.get("urine"), entitiesMap.get("poop")) match {
        case (MaybeWordAsCount(peeCount), MaybeWordAsCount(poopCount)) if peeCount + poopCount > 0 =>
          SiftedContents(peeCount = peeCount, poopCount = poopCount).validNel
        case _ =>
          s"entities map did not contain recognized urine or poop count: $entitiesMap".invalidNel
      }
    }
  }

  case object set_the_lights extends KnownIntentADT[SetTheLights]("set_the_lights") {
    def unapply(rasaResult: RasaResult): Option[ValidatedNel[String, SetTheLights]] = {
      unapplyHelper(rasaResult) { (entitiesMap, confidence) =>
        val validatedColor = entitiesMapToValidatedOptional(entitiesMap, "color", Color.unapply)
        val validatedBrightness: ValidatedNel[String, Option[Int]] = entitiesMapToValidatedOptional(entitiesMap, "brightness", Brightness.unapply)
        val validatedLightOn: ValidatedNel[String, Option[Boolean]] = entitiesMapToValidatedOptional(entitiesMap, "light_state", LightOn.unapply)
        (validatedColor, validatedBrightness, validatedLightOn).mapN { (maybeColor, maybeBrightness, maybeSetOnOff) =>
          SetTheLights(confidence, maybeColor, maybeBrightness, maybeSetOnOff)
        }
      }
    }
  }

  case object no_intent extends KnownIntentADT[NoIntent]("no_intent") {
    def unapply(rasaResult: RasaResult): Option[ValidatedNel[String, NoIntent]] = {
      unapplyHelper(rasaResult) { (entitiesMap, confidence) =>
        val validatedCat = entitiesMapToValidatedOptional(entitiesMap, "cat", CatOfMine.unapply)
        validatedCat.map { maybeCat =>
          NoIntent(confidence, maybeCat)
        }
      }
    }
  }
}


sealed trait KnownIntent {
  val confidence: Double
}


sealed trait CatIntent extends KnownIntent

sealed abstract class LitterIntent extends CatIntent

case class ObservedLitterBeingUsed(confidence: Double, litterBoxChoice: LitterBoxChoice, maybeCatOfMine: Option[CatOfMine], maybeUncertainty: Option[String]) extends LitterIntent

case class PosthocLitterObservation(confidence: Double, litterBoxChoice: LitterBoxChoice, isClean: Boolean) extends LitterIntent

case class ObserveSiftedContents(confidence: Double, litterBoxChoice: LitterBoxChoice, siftedContents: SiftedContents) extends LitterIntent

case class SetTheLights(confidence: Double, maybeColor: Option[LightState], maybeBrightness: Option[Int], maybeSetOnOff: Option[Boolean]) extends KnownIntent

case class NoIntent(confidence: Double, cat: Option[CatOfMine]) extends KnownIntent
